# SSL Server Application

## Overview
This is a simple Spring Boot application that demonstrates the use of SHA-256 hashing. The application includes a REST controller that generates a hash from a name and returns it along with some static data.

## Features
- Spring Boot web application
- REST endpoint at `/hash`
- SHA-256 hash generation
- Basic string manipulation

## Prerequisites
- Java Development Kit (JDK) 8 or higher
- Maven
- Spring Boot dependencies (handled by Maven)

## Project Structure
com.snhu.sslserver/
├── SslServerApplication.java    # Main application class
└── SslServerController.java     # REST controller with hash endpoint


## Functionality
The application provides a single endpoint:
- `GET /hash`: Returns:
  - Static data string: "Hello World Check Sum!"
  - Processed name (first name + last name)
  - SHA-256 hash of the name
  - Name of the cipher algorithm used (SHA-256)

## How to Run
1. Ensure you have Java and Maven installed
2. Clone the repository or copy the code
3. Navigate to the project directory
4. Run the application:
   
mvn spring-boot:run
5. Access the endpoint at: `http://localhost:8080/hash`

## Code Details
### SslServerApplication
- Main Spring Boot application class
- Launches the application using SpringApplication.run()

### SslServerController
- REST controller with one endpoint
- Methods:
  - `myHash()`: Generates and returns the hash information
  - `bytesToHex()`: Converts byte array to hexadecimal string
- Features:
  - Uses SHA-256 algorithm via MessageDigest
  - Processes name string by splitting and recombining first and last names
  - Returns formatted HTML response with data and hash

## Dependencies
- Spring Boot Starter Web (included via @SpringBootApplication)
- Java Security (java.security package)
- Java Math (BigInteger)
- Java NIO Charset (StandardCharsets)

## Output Example
When accessing `/hash`, you'll see something like:

data: Hello World Check Sum!

Name: Brad Mills

Name of Cipher Algorithm Used: SHA256 - CheckSum value: 8f434346648f6b96df89dda901c5176b10a6d83961dd3c1ac88b59b2dc327aa4

# CS305
Software Security

Briefly summarize your client, Artemis Financial, and their software requirements. Who was the client? What issue did they want you to address?

For our academic project, we used "Artemis Financial" as a simulated case. This conceptual financial institution emphasized the need for stronger software security measures, namely focusing on encryption, transitioning from HTTP to HTTPS, and enhancing library security.

What did you do very well when you found your client’s software security vulnerabilities? Why is it important to code securely? What value does software security add to a company’s overall wellbeing?

During the Artemis Financial simulation, I quickly identified gaps in encryption and took the initiative to employ the AES protocol. Secure coding practices are paramount as they proactively detect and rectify challenges within the SDLC. A fortified security posture, even in a simulated setting like Artemis Financial, enhances credibility and protects digital interactions.

What part of the vulnerability assessment was challenging or helpful to you?

Separating genuine security threats from false positives was a key challenge during the vulnerability assessment. This process was instructive, honing my ability to concentrate on true security issues within the codebase.

How did you increase layers of security? In the future, what would you use to assess vulnerabilities and decide which mitigation techniques to use?

To reinforce security in the mock exercise, I utilized encryption libraries like AES and integrated Spring Boot for HTTPS server configuration. I also generated a secure SHA256 key using the JDK keytool. Moving forward, my strategy involves leveraging the OWASP tool early in the process, initializing it via Maven with a pom.xml file. By focusing on real threats and eliminating false negatives, I can better manage genuine concerns throughout the SDLC.

How did you make certain the code and software application were functional and secure? After refactoring the code, how did you check to see whether you introduced new vulnerabilities?

To ensure our software's efficacy and robustness, I employed the QWASP tool integrated with Maven through a pom.xml file. After making code changes, I meticulously compared the pre and post-refactoring reports generated by the tool, guaranteeing that no fresh vulnerabilities had emerged.

What resources, tools, or coding practices did you use that might be helpful in future assignments or tasks?

A pivotal tool from this exercise was a connector that transitioned an HTTP interface to a secure HTTPS version, facilitated by Spring Boot. Additionally, the generation of a SHA256 key via the JDK keytool provides a replicable and secure approach for future endeavors.

Employers sometimes ask for examples of work that you have successfully completed to show your skills, knowledge, and experience. What might you show future employers from this assignment?

From the Artemis Financial exercise, I gained valuable insights into identifying, addressing, and rectifying software security vulnerabilities. The experience sharpened my ability to enhance platform security, moving beyond mere theory to practical implementation. It showcased my adeptness at both understanding and resolving complex security challenges, and I would certainly highlight the depth of understanding and practical skills I acquired from this project when discussing my qualifications with prospective employers.
